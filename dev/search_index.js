var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = TraceEstimation","category":"page"},{"location":"#TraceEstimation","page":"Home","title":"TraceEstimation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [TraceEstimation]","category":"page"},{"location":"#TraceEstimation.ChebyHutchSpace-Tuple{AbstractMatrix{T} where T, Number, Number}","page":"Home","title":"TraceEstimation.ChebyHutchSpace","text":"ChebyHutchSpace(A::AbstractMatrix, a::Number, b::Number; fn::Function=invfun, dfn::Function=rademacherDistribution!, m = 4, n = 6)\n\nCreate Chebyshev-Hutchinson Workspace for chebyhutch or chebydiagonal methods.\n\nArguments\n\nA : Symmetric Positive Definite Matrix\na : Bound for minimum eigenvalue of A\nb : Bound for maximum eigenvalue of A\nfn : Function to appy. By default uses inverse function.\ndfn : Distribution function that returns a vector v. By default uses rademacherDistribution!\nm : Iteration number, increase this for precision. By default m = 4\nn : Polynomial degree, increase this for accuracy. By default n = 6\n\n\n\n\n\n","category":"method"},{"location":"#TraceEstimation.HutchWorkspace-Tuple{Any, Function}","page":"Home","title":"TraceEstimation.HutchWorkspace","text":"HutchWorkspace(A; N = 30, skipverify = false)\nHutchWorkspace(A, randfunc::Function; N = 30, skipverify = false)\n\nArguments\n\nA : Symmetric Positive Definite Matrix with Low Condtion Number (k < 500)\nrandfunc : Function to generate random values for x distributed uniformly                (Base: rand(-1.0:2.0:1.0, size(A,1))                Example: f(n) = rand(-1.0:2.0:1.0, n)\nN : Number of iterations (Default: 30)\nskipverify : If false, it will check isposdef(A) (Default: false)\n\n\n\n\n\n","category":"method"},{"location":"#TraceEstimation.SLQWorkspace-Tuple{Any}","page":"Home","title":"TraceEstimation.SLQWorkspace","text":"SLQWorkspace(A::AbstractMatrix; fn::Function, dfn::Function, ctol, m, nv)\n\nCreate an SLQWorkspace for supplied SPD Matrix A. Use it to calculate tr(fn(A)).\n\nArguments\n\nA : Symmetric Positive Definite Matrix\nfn : Function to apply. By default uses inverse function\ndfn : Distribution function for v (random dist. with norm(v) = 1). By default uses rademacherDistribution!(v::Vector, t::Type)\nctol : SLQ Convergence Tolerance value. By default ctol = 0.1\nm : Specify value for lanczos steps. By default m = 15\nnv : Specify value for SLQ iterations. By default nb = 10\n\n\n\n\n\n","category":"method"},{"location":"#TraceEstimation.chebydiagonal-Tuple{ChebyHutchSpace}","page":"Home","title":"TraceEstimation.chebydiagonal","text":"chebydiagonal(w::ChebyHutchSpace)\nchebydiagonal(A::AbstractMatrix, m::Integer, n::Integer; fn::Function=invfun, dfn::Function=rademacherDistribution!)\n\nChebyshev-Hutchinson to estimate diagonal elements of fn(A), for given matrix A and an analytic function fn.\n\nArguments\n\nA : Symmetric Positive Definite Matrix\nm : Iteration number, increase this for precision. By default m = 4\nn : Polynomial degree, increase this for accuracy. By default n = 6\nfn : Function to appy. By default uses inverse function.\ndfn : Distribution function that returns a vector v. By default uses rademacherDistribution!\n\n\n\n\n\n","category":"method"},{"location":"#TraceEstimation.chebyhutch-Tuple{ChebyHutchSpace}","page":"Home","title":"TraceEstimation.chebyhutch","text":"chebyhutch(w::ChebyHutchSpace)\nchebyhutch(A::AbstractMatrix, m::Integer, n::Integer; a::Float64, b::Float64, fn::Function=invfun, dfn::Function=rademacherDistribution!)\nchebyhutch(A::AbstractMatrix; fn::Function=invfun, dfn::Function=rademacherDistribution!)\n\nChebyshev-Hutchinson to estimate tr(fn(A)), for given matrix A and an analytic function fn.\n\nArguments\n\nA : Symmetric Positive Definite Matrix\nm : Iteration number, increase this for precision. By default m = 4\nn : Polynomial degree, increase this for accuracy. By default n = 6\nfn : Function to appy. By default uses inverse function.\ndfn : Distribution function that returns a vector v. By default uses rademacherDistribution!\n\n\n\n\n\n","category":"method"},{"location":"#TraceEstimation.diag_inv-Tuple{AbstractMatrix{T} where T, Int64, Int64}","page":"Home","title":"TraceEstimation.diag_inv","text":"diag_inv(A::AbstractMatrix, n::Int64, p::Int64; pc = \"chol\", model = \"linear\")\n\nDiagonal Approximation algorithm for the matrix inverse.\n\nArguments\n\nA : Symmetric Positive Definite Matrix\nn : Probing vector count for initial approximation.\np : Sample Points count for interpolation\npc : Preconditioner used for initial approximation and cg (\"chol\" - Incomplete Cholesky, \"ilu\" - IncompleteLU, \"amg\" - AlgebraicMultigrid, \"cheby\" - Chebyshev Approximation). Default = \"chol\"\nmodel : Fitting model used for calculation of trace (\"linear\" - Linear Regression, \"pchip\" - PCHIP interpolation). Default = \"linear\".\n\n\n\n\n\n","category":"method"},{"location":"#TraceEstimation.diagapp-Tuple{Any}","page":"Home","title":"TraceEstimation.diagapp","text":"diagapp(A::AbstractMatrix; randfunc=Base.rand)\n\nDiagonal Approximation algorithm for inverse of matrix.\n\nArguments\n\nA : Symmetric Positive Definite Matrix with Low Condtion Number (k < 500)\nrandfunc : Random function for the particular type of matrix A              (An example can be found in test/diagapp.jl)\n\n\n\n\n\n","category":"method"},{"location":"#TraceEstimation.hutch!-Tuple{HutchWorkspace}","page":"Home","title":"TraceEstimation.hutch!","text":"hutch!(w::HutchWorkspace; aitken = false)\nhutch!(A::AbstractArray; N = 30, skipverify = false, aitken = false)\n\nTake a HutchWorkspace object as input, apply hutchinson estimation algorithm and solve for trace  of inverse of the matrix. (in-place version of hutch)\n\n\n\n\n\n","category":"method"},{"location":"#TraceEstimation.slq-Tuple{SLQWorkspace}","page":"Home","title":"TraceEstimation.slq","text":"slq(w::SLQWorkspace; skipverify = false)\nslq(A::AbstractMatrix; skipverify = false, fn::Function = invfun,\ndfn::Function = Base.rand, ctol = 0.1, eps = ϵ, mtol = tol)\n\nSLQ method to calculate tr(fn(A)) for a Symmetric Positive Definite matrix A and an analytic function fn.\n\nArguments\n\nA : Symmetric Positive Definite Matrix\nskipverify : Skip isposdef(A) verification. By default skipverify = false\nfn : Function to apply on A before trace calculation. fn must be analytic λₘ and λ₁ of A. By default fn = inv\ndfn : Distribution function for v (random dist. with norm(v) = 1). By default uses rademacherDistribution!(v::Vector, t::Type)\nctol : SLQ Convergence Tolerance value. Decrease this for higher precision. By default ctol = 0.1\neps : Error bound for lanczos steps calculation. Decrease this for higher accuracy. By default eps = 0.05\nmtol : Tolerance for eigenvalue Convergence. Decrease this for precision. By default mtol = 0.01\n\n\n\n\n\n","category":"method"},{"location":"#TraceEstimation.tr_inv-Tuple{AbstractMatrix{T} where T, Int64, Int64}","page":"Home","title":"TraceEstimation.tr_inv","text":"tr_inv(A::AbstractMatrix, n::Int64, p::Int64; pc = \"chol\", model = \"linear\")\n\nDiagonal Approximation algorithm for calculating trace of the matrix inverse.\n\nArguments\n\nA : Symmetric Positive Definite Matrix\nn : Probing vector count for initial approximation.\np : Sample Points count for interpolation\npc : Preconditioner used for initial approximation and cg (\"chol\" - Incomplete Cholesky, \"ilu\" - IncompleteLU, \"amg\" - AlgebraicMultigrid, \"cheby\" - Chebyshev Approximation). Default = \"chol\"\nmodel : Fitting model used for calculation of trace (\"linear\" - Linear Regression, \"pchip\" - PCHIP interpolation). Default = \"linear\".\n\n\n\n\n\n","category":"method"}]
}
